/**
  * "analysisRoutines.h":
  * --------------------
  * Declaration of methods for analysis of the configurations.
  * For implementation details, see "analysisRoutines.cpp".
  *
  * Needs: "AnnularCell.h".
  *
  * --------------------
  * Includes methods for studying the
  *   a) Order parameters,
  *   b) Clusters, and
  *   c) Defects of tetratic field.
  *
  * --------------------
  * Last modified: 2021-05-09
  * By: M. E. Maza-Cuello
  */

#ifndef ANALYSISROUTINES_H_INCLUDED
#define ANALYSISROUTINES_H_INCLUDED

#include <map>

#include "AnnularCell.h"

// Order Parameters analysis __________________________________________

/**
  * Obtains the indexes of rods lying in a region centered at the given rod
  * for obtaining the local order parameters.
  */
std::vector<int> getAveragingIndexes(const AnnularCell& cell, const Rod& rod);
std::vector<int> getAveragingIndexes(const AnnularCell& cell, const int& index);

/**
  * Computes local tetratic field (q4) at each particle.
  */
std::vector<double> getQ4(AnnularCell& cell);

/**
 * Gets quadratic field from file generated by "getOrderParameters(AnnularCell&,std::string&)".
 * "filepath" is the absolute file path.
 */
std::vector<double> getQ4FromFile(const std::string& filepath, const int& numRodsInFile);

/**
  * Computes the local nematic (q2), tetratic (q4) and smectic (qs)
  * order parameters inside the cell of the cell.
  * Saves the cell configuration and the order parameters (eight columns) as:
  * index,x,y,angle,tilt,q2,q4,qs
  * in two different files, called
  * "filename.txt" (no header, separator: space), and
  * "filename.csv" (with header, separator: comma).
  * Note: "filename" should not include the file extension.
  * Note: the "indexes" begin with 1.
  */
void getOrderParameters(AnnularCell& cell, std::string& filename);

// Auxiliary tree-structure ___________________________________________

struct Link
{
  int left;
  int right;
};

/**
  * Construct tree hierarchy from links.
  * Each key represents an index belonging to at least one link.
  * The value of a key may be either:
  * a) a vector containing a single
  *    non-positive (<= 0) integer val, which implies that
  *    the key is a leaf of the root = -val; or
  * b) a vector containing non-negative (>= 0) integers, which signals
  *    the key as a root.
  */
std::map< int, std::vector<int> > getTrees(std::vector<Link> links);

/**
  * Erases the leaves of the trees.
  * Any element consisting of strictly less than "minSize" values is removed.
  */
void eraseLeaves(std::map< int, std::vector<int> >& trees, const int& minSize);

// Clusters analysis __________________________________________________

bool areInSameCluster(Rod self, Rod other);

/**
  * Gets the set of (unique, directed) links connecting pairs of rods that satisfy
  * the condition to be on the same cluster.
  * Note: for all links, link.left < link.right.
  */
std::vector<Link> getClusterLinks(AnnularCell& cell);

/**
  * Gets the map of clusters of the cell.
  * Note: isolated rods do not form part of any clusters.
  * See also:
  *   getTrees(std::vector<Link>) for construction of the map,
  *   getClusterLabels(AnnularCell&) for obtaining directly the labels.
  */
std::map< int, std::vector<int> > getClusters(AnnularCell& cell);

/**
  * Gets the label (>= 0) of the cluster to which each rod belongs to.
  * Note: labels do not follow any specific order
  * (in particular, some numbers may be skipped).
  * The labels satisfy: label[index] <= index.
  * If: label[index] = -1, then the rod "index" is isolated.
  */
std::vector<int> getClusterLabels(AnnularCell& cell);

/**
  * Obtains the clusters in a given cell and saves the cell configuration
  * together with the cluster label of each rod (five columns) as:
  * index,x,y,angle,label
  * in two different files, called
  * "filename.txt" (no header, separator: space), and
  * "filename.csv" (with header, separator: comma).
  * Note: "filename" should not include the file extension.
  * Note: the "indexes" begin with 1.
  */
void saveCellWithClusters(AnnularCell& cell, std::string& filename);

// q4-defects analysis ________________________________________________

/**
 * Get all particles that belong to any defect of the quadratic field.
 */
std::vector<int> getParticlesInDefects(const std::vector<double>& q4);

bool areInSameDefect(Rod self, Rod other);

/**
  * Gets the set of (unique, directed) links connecting pairs of rods that satisfy
  * the condition to be on the same defect of the tetratic (q4) field.
  * Note: for all links, link.left < link.right.
  */
std::vector<Link> getDefectsLinks(AnnularCell& cell, const std::vector<double>& q4);
inline std::vector<Link> getDefectsLinks(AnnularCell& cell);

/**
  * Gets the map of defects of the cell.
  * Note: only a subset of particles belong to any defect.
  * See also:
  *   getTrees(std::vector<Link>) for construction of the map,
  *   getDefectsLabels(AnnularCell&) for obtaining only the label of each rod,
  *   eraseLeaves(std::map< int, std::vector<int> >&) for erasing the leaves.
  */
std::map< int, std::vector<int> > getDefects(AnnularCell& cell, const std::vector<double>& q4);
inline std::map< int, std::vector<int> > getDefects(AnnularCell& cell);

/**
  * Gets the label (>= 0) of the defect to which each rod belongs to.
  * Note: labels do not follow any specific order
  * (in particular, some numbers may be skipped).
  * The labels satisfy: label[index] <= index.
  * If: label[index] = -1, then the rod "index" is not part of a defect.
  */
std::vector<int> getDefectsLabels(AnnularCell& cell, const std::vector<double>& q4);
inline std::vector<int> getDefectsLabels(AnnularCell& cell);

/**
  * Returns a map composed by the pairs:
  *   < key: defect label, value: number of elements of defect >.
  * Only defects composed of more than one (> 1) rods are considered.
  */
std::map<int,int> getDefectsSizes(std::map<int,std::vector<int>> defects);

/**
  * Returns a map composed by the pairs:
  *   < key: defect label, value: {x,y} >.
  * Where {x,y} is the averaged position of all rods belonging to the defect,
  * in Cartesian coordinates.
  * Only defects composed of more than one (> 1) rods are considered.
  */
std::map<int,std::vector<double>> getDefectsCartesianCoords(std::map<int,std::vector<int>> defects, AnnularCell& cell);

/**
  * Returns a map composed by the pairs:
  *   < key: defect label, value: {r,theta} >.
  * Where {r,theta} is the averaged position of all rods belonging to the defect,
  * in polar coordinates.
  * Note: theta is in [-pi, pi].
  * Note: r < OUTER_RADIUS, but it could be that r < INNER_RADIUS depending on defect shape.
  * Only defects composed of more than one (> 1) rods are considered.
  */
std::map<int,std::vector<double>> getDefectsPolarCoords(std::map<int,std::vector<int>> defects, AnnularCell& cell);

/**
  * Obtains the defects in a given cell and saves the cell configuration
  * together with the defect label of each rod (five columns) as:
  * index,x,y,angle,label
  * in two different files, called
  * "filename.txt" (no header, separator: space), and
  * "filename.csv" (with header, separator: comma).
  * Note: "filename" should not include the file extension.
  * Note: the "indexes" begin with 1.
  */
void saveCellWithDefects(AnnularCell& cell, std::string& filename, const std::vector<double>& q4);
inline void saveCellWithDefects(AnnularCell& cell, std::string& filename);

#endif // ANALYSISROUTINES_H_INCLUDED
